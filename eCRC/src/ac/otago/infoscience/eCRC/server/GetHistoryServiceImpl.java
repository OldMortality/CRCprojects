/*

Disclaimer of Warranties. The author disclaims to the fullest extent authorized by law any and all other warranties, 
whether express or implied, including, without limitation, any implied warranties of title, non-infringement, quiet enjoyment, 
integration, merchantability or fitness for a particular purpose. Without limitation of the foregoing, the author expressly 
does not warrant that:
(a) the software will meet your requirements or expectations;
(b) the software or the software content] will be free of bugs, errors, viruses or other defects;
(c) any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
(d) the software will be compatible with third party software;
(e) any errors in the software will be corrected.

Under no circumstances shall the author be liable to any user for direct, indirect, incidental, consequential, 
special, or exemplary damages, arising from the software, or user's use or misuse of the software or any other services 
provided by the author. 

Such limitation of liability shall apply whether the damages arise from the use or
misuse of the software or any other services supplied by the author
(including such damages incurred by third parties), or errors of the software.

The software is supplied “as is” and all use is at your own risk.



Author: Michel de Lange

Dunedin, January 2014.

*/

package ac.otago.infoscience.eCRC.server;

 

import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.hibernate.Query;
import org.hibernate.Session;

import ac.otago.infoscience.eCRC.client.GetHistoryService;
import ac.otago.infoscience.eCRC.server.db.Comment;
import ac.otago.infoscience.eCRC.server.db.HibernateUtil;
import ac.otago.infoscience.eCRC.server.db.Relations;
import ac.otago.infoscience.eCRC.shared.CancerHistory;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;


/**
 * Server side class, which updates the database with the family history of cancer.
 * 
 * @author michel
 *
 */

@SuppressWarnings("serial")

public class GetHistoryServiceImpl  extends RemoteServiceServlet implements
		GetHistoryService {

	
	private static final long MAX_OLD =  30 * 60 * 1000;;
	private static Logger logger = Logger
			.getLogger("ac.otago.infoscience.eCRC.server.GetHistoryServiceImpl");
	

	/**
	 * Get the cancer history for the erefID from the server.
	 * 
	 * @author michel
	 *
	 * @param erefID: unique ID, provided by the ereferral system. 
	 *
	 */

	public CancerHistory[] getHistory(String erefID) throws IllegalArgumentException { 
			 
			String ipAddressInRequest = getThreadLocalRequest().getRemoteAddr();
		    
			long timestamp = -1;
			
			
			String ipAddressInDB = getThreadLocalRequest().getRemoteAddr();
			
			boolean first = true;
			
			
			CancerHistory[] result = null;
			
			try {
			
				logger.info("getting relations for erefID: "+ erefID);
				
				Session session = HibernateUtil.getSessionFactory().openSession();
				
				//where relation.erefID = :e order by relation.relationshipType
				
				Query q = session.createQuery(
			
						"from Relations as relation where relation.erefID = :e order by relation.relationshipType ")
						
						.setString("e", erefID);
			 
				//Iterator<Relations> i = (Iterator<Relations>) q.iterate();
				
				List<Relations> list =  q.list() ;
				
				Iterator<Relations> i = (Iterator<Relations>) list.iterator();
				
				logger.debug("Listing relations for erefID  " + erefID);
	            
				
				if (list.size() > 1) {
					
					result = new CancerHistory[list.size() - 1];
					
				} else {
					
					return null;
					
				}
				
				
				
				int count = 0;
				
				while (i.hasNext()) {
				
					count++;
					
					Relations rel = (Relations) i.next() ;
					
					if (first) {
						
						// don't include the first, because this is the patient himself
						
						// the time in ms when this record was created.
						
						timestamp =  rel.getTimest().getTime(); 
					
						ipAddressInDB = rel.getIpAddress();
										
						 
						first = false;
						
						 
						
					} else {
						
						String erefid = rel.getErefID();
						
						short type = rel.getRelationshipType();
						
						String name = rel.getName();
			
						boolean colonCancer = false;
						
						if (rel.getColonCancer() == 1) {
						
							colonCancer = true;
							
						}
						
						short ccAge = rel.getColonCancerAge();
						
						boolean multPols = false;
						
						if (rel.getMultiplePolyps() == 1) {
							
							multPols = true;
						}
						
						boolean otherCancer = false;
						
						if (rel.getOtherCancer() == 1) {
							
							otherCancer = true;
						}
						
						short oAge = rel.getOtherCancerAge();
						
						boolean deceased = false;
						
						if (rel.getDeceased() == 1) {
							
							deceased = true;
						
						}
						
						short dAge = rel.getDeceasedAge();
						
						// not in the database.
						String nhiNumber = "";
						
					 
						
						Comment comment = rel.getComment();

						String commentString = comment.getComment();
						
						CancerHistory thisOne = new CancerHistory(nhiNumber,
								erefid,
								type,
								name,
								colonCancer,
								ccAge,
								multPols,
								otherCancer,
								oAge,
								deceased,
								dAge,
								commentString);
						
						// first count is the patient himself, and array starts at zero. so -2.
						result[count - 2] = thisOne;
						
					}
					
					
				}
				logger.debug("Found this many relations for erefId "+ erefID + " : " + count);
				
				session.close();
			
			} catch (Exception e) {
				
				logger.log(Level.ERROR
						,"error getting relation ", e);
				
				return null;
			
			}
			
			// handle the case where there were no records found for this erefid;
			
			if (first) {
			
				logger.debug("No relations found for erefID: " + erefID);
				
				return null;
			
			}
			
			// handle the case where the data is too old. This web service will not return
			// records older than MAX_OLD (ms), for security reasons.
			
			// Also for security reasons, the web service will only return records if the IP address on the request
			// is the same as that on the database. This depends on a setting in ecrcrest.properties. You can turn
			// this feature off by putting in there: allow_header=false
			
			if( timestamp > 0  ) {
			
				long now = System.currentTimeMillis();
				
				if (now - timestamp > MAX_OLD  ) {
				
					logger.log(Level.ERROR, "Request too old. erefid, ipAddress = " + erefID + " " + ipAddressInRequest);
					
					return null;
				}
				
				if (  !( ipAddressInRequest.equals(ipAddressInDB) ) ) {
					
					logger.log(Level.ERROR, "IPaddress in request does not match ipAddress on database. " +
				  " erefId, ipAddressRequest, ipAddressDB  = " + erefID + " " + ipAddressInRequest + " " + ipAddressInDB);
					
					return null;
				
				}
			}
			
					
			return result;
		}
	
		
}
